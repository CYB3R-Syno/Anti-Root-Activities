# CVE-2016-0728 [Linux Kernel]
작성자 : Syno

### [Introduction], [서론]
사실.. 무엇을 할까 고민하다가 요새 Pwnable하면서.. Kernel에 대해서 굉장히 궁금해져서 선택하게되었습니다,,     
먼저 해당 [CVE-2016-0728](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0728)은 ```keyctl``` 이라는 Command에 취약점이 존재한다고 알려져있습니다.     
- Linux Kernel에 경우 4.4.1 버전보다 낮은 경우에 취약점이 발생합니다.     

<hr>

[Vulnerability Information]
```
The join_session_keyring function in security/keys/process_keys.c in the Linux kernel before 4.4.1 mishandles object references in a certain error case, 
which allows local users to gain privileges or cause a denial of service (integer overflow and use-after-free) via crafted keyctl commands.
```

[Vulnerability Type]
```
Integer Overflow, Use-After-Free라고하며, Exploit 과정은 Use-After-Free에 속한다고 합니다.
```

<hr>

### [Body], [본문]
먼저 [keyctl](https://man7.org/linux/man-pages/man2/keyctl.2.html) 에 대해서 알아보았습니다.    
```keyctl``` : 커널에 키(Key)를 관리하거나 보유를 총괄하는 시스템

그렇다면 취약점이 발생하는 함수는 ?
- join_session_keyring

1. ```Keyring``` 이란 Kernel에 있는 여러가지에 데이터를 저장하는 부분이며, ```Struct Key``` 형태로 구성이 되어있다고한다.
2. ```join_session_keyring``` 이란 해당 CVE에 취약한 함수이며 프로세스가 등록된 세션 키링을 변경하는 역할을 한다.

```c
/*
 * Join the named keyring as the session keyring if possible else attempt to
 * create a new one of that name and join that.
 *
 * If the name is NULL, an empty anonymous keyring will be installed as the
 * session keyring.
 *
 * Named session keyrings are joined with a semaphore held to prevent the
 * keyrings from going away whilst the attempt is made to going them and also
 * to prevent a race in creating compatible session keyrings.
 */
long join_session_keyring(const char *name)
{
	const struct cred *old;
	struct cred *new;
	struct key *keyring;
	long ret, serial;
 
	new = prepare_creds();
	if (!new)
		return -ENOMEM;
	old = current_cred();
 
	/* if no name is provided, install an anonymous keyring */
	if (!name) {
		ret = install_session_keyring_to_cred(new, NULL);
		if (ret < 0)
			goto error;
 
		serial = new->session_keyring->serial;
		ret = commit_creds(new);
		if (ret == 0)
			ret = serial;
		goto okay;
	}
 
	/* allow the user to join or create a named keyring */
	mutex_lock(&key_session_mutex);
 
	/* look for an existing keyring of this name */
	keyring = find_keyring_by_name(name, false);
	if (PTR_ERR(keyring) == -ENOKEY) {
		/* not found - try and create a new one */
		keyring = keyring_alloc(
			name, old->uid, old->gid, old,
			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,
			KEY_ALLOC_IN_QUOTA, NULL);
		if (IS_ERR(keyring)) {
			ret = PTR_ERR(keyring);
			goto error2;
		}
	} else if (IS_ERR(keyring)) {
		ret = PTR_ERR(keyring);
		goto error2;
	} else if (keyring == new->session_keyring) {
		ret = 0;
		goto error2;
	}
 
	/* we've got a keyring - now to install it */
	ret = install_session_keyring_to_cred(new, keyring);
	if (ret < 0)
		goto error2;
 
	commit_creds(new);
	mutex_unlock(&key_session_mutex);
 
	ret = keyring->serial;
	key_put(keyring);
okay:
	return ret;
 
error2:
	mutex_unlock(&key_session_mutex);
error:
	abort_creds(new);
	return ret;
}
```

위 함수는 keyctl 로 호출할 수 있습니다.     
- KEYCTL_JOIN_SESSION_KEYRING, '이름'

즉 다음과 같은 상황에서는 현재 Session에서 원하는 이름으로 Keyring을 생성할 수 있습니다.

<hr>

### [Analyze]
```c
long join_session_keyring(const char *name)
{
	const struct cred *old;
	struct cred *new;
	struct key *keyring;
	long ret, serial;
 
	new = prepare_creds(); 
	if (!new)
		return -ENOMEM;
	old = current_cred();
 
	/* if no name is provided, install an anonymous keyring */
	if (!name) {
		ret = install_session_keyring_to_cred(new, NULL);
		if (ret < 0)
			goto error;
 
		serial = new->session_keyring->serial;
		ret = commit_creds(new);
		if (ret == 0)
			ret = serial;
		goto okay;
	}
```
  
keyctl() 함수에서 2번째 인자에 null을 주게되면 keyring 이름이 랜덤하게 생성되는것을 알 수 있다.    
다만 우리가 테스트하려는 경우는 이름을 줄 것이기 때문에 해당 조건문으로는 들어오지 않는다.


```c
/* allow the user to join or create a named keyring */
	mutex_lock(&key_session_mutex);
 
	/* look for an existing keyring of this name */
	keyring = find_keyring_by_name(name, false); // ref-count 증가
	if (PTR_ERR(keyring) == -ENOKEY) {
		/* not found - try and create a new one */
		keyring = keyring_alloc( // 주어진 이름으로 세션 키링 생성
			name, old->uid, old->gid, old,
			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,
			KEY_ALLOC_IN_QUOTA, NULL);
		if (IS_ERR(keyring)) {
			ret = PTR_ERR(keyring);
			goto error2;
		}
	} else if (IS_ERR(keyring)) {
		ret = PTR_ERR(keyring);
		goto error2;
	} else if (keyring == new->session_keyring) {
		ret = 0;
		goto error2;
	}
 
	/* we've got a keyring - now to install it */
	ret = install_session_keyring_to_cred(new, keyring); // ref-count 증가
	if (ret < 0)
		goto error2;
 
	commit_creds(new);
	mutex_unlock(&key_session_mutex);
 
	ret = keyring->serial;
	key_put(keyring); // ref-count 감소
okay:
	return ret;
 
error2:
	mutex_unlock(&key_session_mutex);
error:
	abort_creds(new); 
	return ret;
}
```


